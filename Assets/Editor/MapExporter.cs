using UnityEngine;
using UnityEngine.Rendering;
using UnityEditor;
using UnityEditor.SceneManagement;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;

public static class MapExporter
{
    private const float EdgeEpsilon = 0.01f;
    private const float MaxSlopeAngle = 45f;
    private static readonly string OutputDir = Path.Combine(Application.dataPath, "Scripts", "SharedPhysics");

    [MenuItem("Tools/Export Map Data")]
    public static void ExportMapData()
    {
        var terrainMeshes = Object.FindObjectsByType<TerrainMesh>(FindObjectsSortMode.None);
        if (terrainMeshes.Length == 0)
        {
            EditorUtility.DisplayDialog("Export Failed", "No TerrainMesh components found in the scene.", "OK");
            return;
        }

        var spawnPoints = Object.FindObjectsByType<SpawnPoint>(FindObjectsSortMode.None);
        if (spawnPoints.Length == 0)
        {
            EditorUtility.DisplayDialog("Export Failed", "No SpawnPoint components found in the scene.", "OK");
            return;
        }

        var allEdges = new List<Edge2D>();
        var allTriangles = new List<Triangle3D>();

        foreach (var terrainMesh in terrainMeshes)
        {
            Mesh mesh;
            bool isGeneratedMesh = false;

            var meshFilter = terrainMesh.GetComponent<MeshFilter>();
            var unityTerrain = terrainMesh.GetComponent<Terrain>();

            if (meshFilter != null && meshFilter.sharedMesh != null)
            {
                mesh = meshFilter.sharedMesh;
            }
            else if (unityTerrain != null && unityTerrain.terrainData != null)
            {
                mesh = TerrainToMesh(unityTerrain, terrainMesh.resolution);
                isGeneratedMesh = true;
            }
            else
            {
                Debug.LogWarning($"TerrainMesh on '{terrainMesh.name}' has no MeshFilter or Terrain component. Skipping.");
                continue;
            }

            var boundaryEdges = ExtractBoundaryEdges(mesh, terrainMesh.transform);
            allEdges.AddRange(boundaryEdges);

            var triangles = ExtractTriangles(mesh, terrainMesh.transform);
            allTriangles.AddRange(triangles);

            var slopeEdges = ExtractSlopeTransitionEdges(mesh, terrainMesh.transform, MaxSlopeAngle);
            allEdges.AddRange(slopeEdges);

            if (isGeneratedMesh)
            {
                Object.DestroyImmediate(mesh);
            }
        }

        var deduplicatedEdges = DeduplicateSharedEdges(allEdges);
        var deduplicatedTriangles = DeduplicateSharedTriangles(allTriangles);
        Debug.Log($"Extracted {allEdges.Count} boundary edges, {deduplicatedEdges.Count} after deduplication.");
        Debug.Log($"Extracted {allTriangles.Count} triangles, {deduplicatedTriangles.Count} after deduplication.");

        var spawnPos = spawnPoints[0].transform.position;
        var mapName = EditorSceneManager.GetActiveScene().name;

        // Write per-map file
        var mapFilePath = Path.Combine(OutputDir, $"MapData.{mapName}.cs");
        var mapCode = GenerateMapFile(mapName, deduplicatedEdges, deduplicatedTriangles, spawnPos);
        File.WriteAllText(mapFilePath, mapCode);

        // Regenerate index from all existing per-map files
        var allMapNames = DiscoverMapNames();
        var indexCode = GenerateIndexFile(allMapNames);
        var indexFilePath = Path.Combine(OutputDir, "MapData.cs");
        File.WriteAllText(indexFilePath, indexCode);

        AssetDatabase.Refresh();

        EditorUtility.DisplayDialog(
            "Export Complete",
            $"Exported map '{mapName}' ({deduplicatedEdges.Count} collision lines, {deduplicatedTriangles.Count} triangles).\n{allMapNames.Count} total map(s) registered.",
            "OK"
        );
    }

    private static List<string> DiscoverMapNames()
    {
        var mapNames = new List<string>();
        foreach (var file in Directory.GetFiles(OutputDir, "MapData.*.cs"))
        {
            var fileName = Path.GetFileNameWithoutExtension(file);
            // fileName is "MapData.{MapName}", extract the map name
            var mapName = fileName.Substring("MapData.".Length);
            mapNames.Add(mapName);
        }
        mapNames.Sort();
        return mapNames;
    }

    private static string GenerateIndexFile(List<string> mapNames)
    {
        var code = new StringBuilder();
        code.AppendLine("// Auto-generated by MapExporter. Do not edit.");
        code.AppendLine("namespace SharedPhysics");
        code.AppendLine("{");
        code.AppendLine("    public static partial class MapData");
        code.AppendLine("    {");

        code.AppendLine("        public static MapDefinition GetMap(string name) => name switch");
        code.AppendLine("        {");
        foreach (var name in mapNames)
        {
            code.AppendLine($"            \"{name}\" => {name},");
        }
        code.AppendLine("            _ => throw new System.ArgumentException($\"Unknown map: {name}\")");
        code.AppendLine("        };");
        code.AppendLine();

        // Helper methods for converting flat float arrays to Line[]/Triangle[]
        code.AppendLine("        private static Line[] BuildLines(float[] data)");
        code.AppendLine("        {");
        code.AppendLine("            var result = new Line[data.Length / 4];");
        code.AppendLine("            for (int i = 0; i < result.Length; i++)");
        code.AppendLine("            {");
        code.AppendLine("                int j = i * 4;");
        code.AppendLine("                result[i] = new Line(new Vector2(data[j], data[j + 1]), new Vector2(data[j + 2], data[j + 3]));");
        code.AppendLine("            }");
        code.AppendLine("            return result;");
        code.AppendLine("        }");
        code.AppendLine();
        code.AppendLine("        private static Triangle[] BuildTriangles(float[] data)");
        code.AppendLine("        {");
        code.AppendLine("            var result = new Triangle[data.Length / 9];");
        code.AppendLine("            for (int i = 0; i < result.Length; i++)");
        code.AppendLine("            {");
        code.AppendLine("                int j = i * 9;");
        code.AppendLine("                result[i] = new Triangle(");
        code.AppendLine("                    new Vector3(data[j], data[j + 1], data[j + 2]),");
        code.AppendLine("                    new Vector3(data[j + 3], data[j + 4], data[j + 5]),");
        code.AppendLine("                    new Vector3(data[j + 6], data[j + 7], data[j + 8]));");
        code.AppendLine("            }");
        code.AppendLine("            return result;");
        code.AppendLine("        }");

        code.AppendLine("    }");
        code.AppendLine("}");

        return code.ToString();
    }

    private static string GenerateMapFile(string mapName, List<Edge2D> lines, List<Triangle3D> triangles, Vector3 spawnPosition)
    {
        var code = new StringBuilder();
        code.AppendLine("// Auto-generated by MapExporter. Do not edit.");
        code.AppendLine("namespace SharedPhysics");
        code.AppendLine("{");
        code.AppendLine("    public static partial class MapData");
        code.AppendLine("    {");

        // Line data as flat float array (4 floats per line: startX, startY, endX, endY)
        // Float arrays use RuntimeHelpers.InitializeArray (binary blob copy), avoiding large IL methods.
        code.AppendLine($"        private static readonly float[] _{mapName}LineData = new float[]");
        code.AppendLine("        {");
        for (int i = 0; i < lines.Count; i++)
        {
            var line = lines[i];
            code.AppendLine($"            {F(line.Start.x)},{F(line.Start.y)},{F(line.End.x)},{F(line.End.y)},");
        }
        code.AppendLine("        };");
        code.AppendLine();

        // Triangle data as flat float array (9 floats per tri: v0x,v0y,v0z, v1x,v1y,v1z, v2x,v2y,v2z)
        code.AppendLine($"        private static readonly float[] _{mapName}TriangleData = new float[]");
        code.AppendLine("        {");
        for (int i = 0; i < triangles.Count; i++)
        {
            var tri = triangles[i];
            code.AppendLine($"            {F(tri.V0.x)},{F(tri.V0.y)},{F(tri.V0.z)},{F(tri.V1.x)},{F(tri.V1.y)},{F(tri.V1.z)},{F(tri.V2.x)},{F(tri.V2.y)},{F(tri.V2.z)},");
        }
        code.AppendLine("        };");
        code.AppendLine();

        // Lazy map definition - only constructed when first accessed
        code.AppendLine($"        private static readonly System.Lazy<MapDefinition> _{mapName}Lazy = new System.Lazy<MapDefinition>(() => new MapDefinition(");
        code.AppendLine($"            \"{mapName}\",");
        code.AppendLine($"            BuildLines(_{mapName}LineData),");
        code.AppendLine($"            BuildTriangles(_{mapName}TriangleData),");
        code.AppendLine($"            new Vector3({F(spawnPosition.x)}, {F(spawnPosition.y)}, {F(spawnPosition.z)})");
        code.AppendLine("        ));");
        code.AppendLine($"        public static MapDefinition {mapName} => _{mapName}Lazy.Value;");

        code.AppendLine("    }");
        code.AppendLine("}");

        return code.ToString();
    }

    private static Mesh TerrainToMesh(Terrain terrain, int resolution)
    {
        var data = terrain.terrainData;
        var hmRes = data.heightmapResolution;
        var size = data.size;

        resolution = Mathf.Clamp(resolution, 2, hmRes);
        int step = Mathf.Max(1, (hmRes - 1) / (resolution - 1));
        int actualRes = (hmRes - 1) / step + 1;

        var heights = data.GetHeights(0, 0, hmRes, hmRes);
        var vertices = new Vector3[actualRes * actualRes];

        for (int z = 0; z < actualRes; z++)
        {
            for (int x = 0; x < actualRes; x++)
            {
                int hmX = Mathf.Min(x * step, hmRes - 1);
                int hmZ = Mathf.Min(z * step, hmRes - 1);

                float xPos = (float)hmX / (hmRes - 1) * size.x;
                float yPos = heights[hmZ, hmX] * size.y;
                float zPos = (float)hmZ / (hmRes - 1) * size.z;

                vertices[z * actualRes + x] = new Vector3(xPos, yPos, zPos);
            }
        }

        var triangles = new int[(actualRes - 1) * (actualRes - 1) * 6];
        int idx = 0;

        for (int z = 0; z < actualRes - 1; z++)
        {
            for (int x = 0; x < actualRes - 1; x++)
            {
                int topLeft = z * actualRes + x;
                int topRight = topLeft + 1;
                int bottomLeft = (z + 1) * actualRes + x;
                int bottomRight = bottomLeft + 1;

                triangles[idx++] = topLeft;
                triangles[idx++] = bottomLeft;
                triangles[idx++] = topRight;

                triangles[idx++] = topRight;
                triangles[idx++] = bottomLeft;
                triangles[idx++] = bottomRight;
            }
        }

        var mesh = new Mesh();
        if (vertices.Length > 65535)
            mesh.indexFormat = IndexFormat.UInt32;
        mesh.vertices = vertices;
        mesh.triangles = triangles;

        Debug.Log($"Generated mesh from Terrain '{terrain.name}': {actualRes}x{actualRes} grid, {vertices.Length} vertices, {triangles.Length / 3} triangles");
        return mesh;
    }

    private static List<Triangle3D> ExtractTriangles(Mesh mesh, Transform transform)
    {
        var triangles = mesh.triangles;
        var vertices = mesh.vertices;
        var result = new List<Triangle3D>();

        for (int i = 0; i < triangles.Length; i += 3)
        {
            var worldV0 = transform.TransformPoint(vertices[triangles[i]]);
            var worldV1 = transform.TransformPoint(vertices[triangles[i + 1]]);
            var worldV2 = transform.TransformPoint(vertices[triangles[i + 2]]);

            result.Add(new Triangle3D(worldV0, worldV1, worldV2));
        }

        return result;
    }

    private static List<Edge2D> ExtractBoundaryEdges(Mesh mesh, Transform transform)
    {
        var triangles = mesh.triangles;
        var vertices = mesh.vertices;
        var edgeCounts = new Dictionary<(int, int), int>();

        for (int i = 0; i < triangles.Length; i += 3)
        {
            var v0 = triangles[i];
            var v1 = triangles[i + 1];
            var v2 = triangles[i + 2];

            CountEdge(edgeCounts, v0, v1);
            CountEdge(edgeCounts, v1, v2);
            CountEdge(edgeCounts, v2, v0);
        }

        var boundaryEdges = new List<Edge2D>();
        foreach (var kvp in edgeCounts)
        {
            if (kvp.Value != 1) continue;

            var worldA = transform.TransformPoint(vertices[kvp.Key.Item1]);
            var worldB = transform.TransformPoint(vertices[kvp.Key.Item2]);

            boundaryEdges.Add(new Edge2D(
                new Vector2(worldA.x, worldA.z),
                new Vector2(worldB.x, worldB.z)
            ));
        }

        return boundaryEdges;
    }

    private static List<Edge2D> ExtractSlopeTransitionEdges(Mesh mesh, Transform transform, float maxSlopeAngle)
    {
        var triangles = mesh.triangles;
        var vertices = mesh.vertices;
        var edgeTriangles = new Dictionary<(int, int), List<int>>();

        for (int i = 0; i < triangles.Length; i += 3)
        {
            int triIdx = i / 3;
            AddEdgeTri(edgeTriangles, triangles[i], triangles[i + 1], triIdx);
            AddEdgeTri(edgeTriangles, triangles[i + 1], triangles[i + 2], triIdx);
            AddEdgeTri(edgeTriangles, triangles[i + 2], triangles[i], triIdx);
        }

        var result = new List<Edge2D>();
        foreach (var kvp in edgeTriangles)
        {
            if (kvp.Value.Count != 2) continue;

            bool walkableA = IsTriangleWalkable(kvp.Value[0], triangles, vertices, transform, maxSlopeAngle);
            bool walkableB = IsTriangleWalkable(kvp.Value[1], triangles, vertices, transform, maxSlopeAngle);

            if (walkableA != walkableB)
            {
                var worldA = transform.TransformPoint(vertices[kvp.Key.Item1]);
                var worldB = transform.TransformPoint(vertices[kvp.Key.Item2]);
                result.Add(new Edge2D(
                    new Vector2(worldA.x, worldA.z),
                    new Vector2(worldB.x, worldB.z)
                ));
            }
        }
        return result;
    }

    private static void AddEdgeTri(Dictionary<(int, int), List<int>> edgeTriangles, int a, int b, int triIdx)
    {
        var key = a < b ? (a, b) : (b, a);
        if (!edgeTriangles.TryGetValue(key, out var list))
        {
            list = new List<int>();
            edgeTriangles[key] = list;
        }
        list.Add(triIdx);
    }

    private static bool IsTriangleWalkable(int triIdx, int[] triangles, Vector3[] vertices, Transform transform, float maxSlopeAngle)
    {
        int i = triIdx * 3;
        var worldV0 = transform.TransformPoint(vertices[triangles[i]]);
        var worldV1 = transform.TransformPoint(vertices[triangles[i + 1]]);
        var worldV2 = transform.TransformPoint(vertices[triangles[i + 2]]);

        var edge1 = worldV1 - worldV0;
        var edge2 = worldV2 - worldV0;
        var normal = Vector3.Cross(edge1, edge2).normalized;

        var angle = Vector3.Angle(normal, Vector3.up);
        // Check both orientations (normal could point up or down depending on winding)
        if (angle > 90f) angle = 180f - angle;
        return angle <= maxSlopeAngle;
    }

    private static void CountEdge(Dictionary<(int, int), int> edgeCounts, int a, int b)
    {
        var key = a < b ? (a, b) : (b, a);
        edgeCounts.TryGetValue(key, out var count);
        edgeCounts[key] = count + 1;
    }

    private static List<Edge2D> DeduplicateSharedEdges(List<Edge2D> edges)
    {
        var result = new List<Edge2D>();
        var removed = new bool[edges.Count];

        for (int i = 0; i < edges.Count; i++)
        {
            if (removed[i]) continue;

            bool isDuplicate = false;
            for (int j = i + 1; j < edges.Count; j++)
            {
                if (removed[j]) continue;
                if (!EdgesMatch(edges[i], edges[j])) continue;

                removed[i] = true;
                removed[j] = true;
                isDuplicate = true;
                break;
            }

            if (!isDuplicate)
            {
                result.Add(edges[i]);
            }
        }

        return result;
    }

    private static List<Triangle3D> DeduplicateSharedTriangles(List<Triangle3D> triangles)
    {
        var result = new List<Triangle3D>();
        var removed = new bool[triangles.Count];

        for (int i = 0; i < triangles.Count; i++)
        {
            if (removed[i]) continue;

            bool isDuplicate = false;
            for (int j = i + 1; j < triangles.Count; j++)
            {
                if (removed[j]) continue;
                if (!TrianglesMatch(triangles[i], triangles[j])) continue;

                removed[i] = true;
                removed[j] = true;
                isDuplicate = true;
                break;
            }

            if (!isDuplicate)
            {
                result.Add(triangles[i]);
            }
        }

        return result;
    }

    private static bool TrianglesMatch(Triangle3D a, Triangle3D b)
    {
        var aVerts = new[] { a.V0, a.V1, a.V2 };
        var bVerts = new[] { b.V0, b.V1, b.V2 };

        // Check if all vertices of a match some vertex in b
        foreach (var av in aVerts)
        {
            bool found = false;
            foreach (var bv in bVerts)
            {
                if (ApproxEqual3D(av, bv))
                {
                    found = true;
                    break;
                }
            }
            if (!found) return false;
        }
        return true;
    }

    private static bool EdgesMatch(Edge2D a, Edge2D b)
    {
        return (ApproxEqual(a.Start, b.Start) && ApproxEqual(a.End, b.End)) ||
               (ApproxEqual(a.Start, b.End) && ApproxEqual(a.End, b.Start));
    }

    private static bool ApproxEqual(Vector2 a, Vector2 b)
    {
        return Mathf.Abs(a.x - b.x) < EdgeEpsilon && Mathf.Abs(a.y - b.y) < EdgeEpsilon;
    }

    private static bool ApproxEqual3D(Vector3 a, Vector3 b)
    {
        return Mathf.Abs(a.x - b.x) < EdgeEpsilon &&
               Mathf.Abs(a.y - b.y) < EdgeEpsilon &&
               Mathf.Abs(a.z - b.z) < EdgeEpsilon;
    }

    private static string F(float value)
    {
        return value.ToString("G", CultureInfo.InvariantCulture) + "f";
    }

    private struct Edge2D
    {
        public Vector2 Start;
        public Vector2 End;

        public Edge2D(Vector2 start, Vector2 end)
        {
            Start = start;
            End = end;
        }
    }

    private struct Triangle3D
    {
        public Vector3 V0;
        public Vector3 V1;
        public Vector3 V2;

        public Triangle3D(Vector3 v0, Vector3 v1, Vector3 v2)
        {
            V0 = v0;
            V1 = v1;
            V2 = v2;
        }
    }
}
