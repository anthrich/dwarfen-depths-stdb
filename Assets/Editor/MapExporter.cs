using UnityEngine;
using UnityEditor;
using UnityEditor.SceneManagement;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Text;

public static class MapExporter
{
    private const float EdgeEpsilon = 0.01f;
    private static readonly string OutputPath = Path.Combine(Application.dataPath, "Scripts", "SharedPhysics", "MapData.cs");

    [MenuItem("Tools/Export Map Data")]
    public static void ExportMapData()
    {
        var terrainMeshes = Object.FindObjectsByType<TerrainMesh>(FindObjectsSortMode.None);
        if (terrainMeshes.Length == 0)
        {
            EditorUtility.DisplayDialog("Export Failed", "No TerrainMesh components found in the scene.", "OK");
            return;
        }

        var spawnPoints = Object.FindObjectsByType<SpawnPoint>(FindObjectsSortMode.None);
        if (spawnPoints.Length == 0)
        {
            EditorUtility.DisplayDialog("Export Failed", "No SpawnPoint components found in the scene.", "OK");
            return;
        }

        var allEdges = new List<Edge2D>();

        foreach (var terrain in terrainMeshes)
        {
            var meshFilter = terrain.GetComponent<MeshFilter>();
            if (meshFilter == null || meshFilter.sharedMesh == null)
            {
                Debug.LogWarning($"TerrainMesh on '{terrain.name}' has no MeshFilter or mesh. Skipping.");
                continue;
            }

            var boundaryEdges = ExtractBoundaryEdges(meshFilter.sharedMesh, terrain.transform);
            allEdges.AddRange(boundaryEdges);
        }

        var deduplicated = DeduplicateSharedEdges(allEdges);
        Debug.Log($"Extracted {allEdges.Count} boundary edges, {deduplicated.Count} after deduplication.");

        var spawnPos = spawnPoints[0].transform.position;
        var spawnPhysics = new Vector2(spawnPos.x, spawnPos.z);

        var mapName = EditorSceneManager.GetActiveScene().name;

        var code = GenerateMapDataClass(mapName, deduplicated, spawnPhysics);
        File.WriteAllText(OutputPath, code);
        AssetDatabase.Refresh();

        EditorUtility.DisplayDialog(
            "Export Complete",
            $"Exported map '{mapName}' ({deduplicated.Count} collision lines) to:\n{OutputPath}",
            "OK"
        );
    }

    private static List<Edge2D> ExtractBoundaryEdges(Mesh mesh, Transform transform)
    {
        var triangles = mesh.triangles;
        var vertices = mesh.vertices;
        var edgeCounts = new Dictionary<(int, int), int>();

        for (int i = 0; i < triangles.Length; i += 3)
        {
            var v0 = triangles[i];
            var v1 = triangles[i + 1];
            var v2 = triangles[i + 2];

            CountEdge(edgeCounts, v0, v1);
            CountEdge(edgeCounts, v1, v2);
            CountEdge(edgeCounts, v2, v0);
        }

        var boundaryEdges = new List<Edge2D>();
        foreach (var kvp in edgeCounts)
        {
            if (kvp.Value != 1) continue;

            var worldA = transform.TransformPoint(vertices[kvp.Key.Item1]);
            var worldB = transform.TransformPoint(vertices[kvp.Key.Item2]);

            boundaryEdges.Add(new Edge2D(
                new Vector2(worldA.x, worldA.z),
                new Vector2(worldB.x, worldB.z)
            ));
        }

        return boundaryEdges;
    }

    private static void CountEdge(Dictionary<(int, int), int> edgeCounts, int a, int b)
    {
        var key = a < b ? (a, b) : (b, a);
        edgeCounts.TryGetValue(key, out var count);
        edgeCounts[key] = count + 1;
    }

    private static List<Edge2D> DeduplicateSharedEdges(List<Edge2D> edges)
    {
        var result = new List<Edge2D>();
        var removed = new bool[edges.Count];

        for (int i = 0; i < edges.Count; i++)
        {
            if (removed[i]) continue;

            bool isDuplicate = false;
            for (int j = i + 1; j < edges.Count; j++)
            {
                if (removed[j]) continue;
                if (!EdgesMatch(edges[i], edges[j])) continue;

                removed[i] = true;
                removed[j] = true;
                isDuplicate = true;
                break;
            }

            if (!isDuplicate)
            {
                result.Add(edges[i]);
            }
        }

        return result;
    }

    private static bool EdgesMatch(Edge2D a, Edge2D b)
    {
        return (ApproxEqual(a.Start, b.Start) && ApproxEqual(a.End, b.End)) ||
               (ApproxEqual(a.Start, b.End) && ApproxEqual(a.End, b.Start));
    }

    private static bool ApproxEqual(Vector2 a, Vector2 b)
    {
        return Mathf.Abs(a.x - b.x) < EdgeEpsilon && Mathf.Abs(a.y - b.y) < EdgeEpsilon;
    }

    private static string GenerateMapDataClass(string mapName, List<Edge2D> lines, Vector2 spawnPosition)
    {
        var code = new StringBuilder();
        code.AppendLine("// Auto-generated by MapExporter. Do not edit.");
        code.AppendLine("namespace SharedPhysics");
        code.AppendLine("{");
        code.AppendLine("    public static class MapData");
        code.AppendLine("    {");

        code.AppendLine("        public static MapDefinition GetMap(string name) => name switch");
        code.AppendLine("        {");
        code.AppendLine($"            \"{mapName}\" => {mapName},");
        code.AppendLine("            _ => throw new System.ArgumentException($\"Unknown map: {name}\")");
        code.AppendLine("        };");

        code.AppendLine();
        code.AppendLine($"        private static readonly MapDefinition {mapName} = new MapDefinition(");
        code.AppendLine("            new Line[]");
        code.AppendLine("            {");
        for (int i = 0; i < lines.Count; i++)
        {
            var line = lines[i];
            var comma = i < lines.Count - 1 ? "," : "";
            code.AppendLine($"                new Line(new Vector2({F(line.Start.x)}, {F(line.Start.y)}), new Vector2({F(line.End.x)}, {F(line.End.y)})){comma}");
        }
        code.AppendLine("            },");
        code.AppendLine($"            new Vector2({F(spawnPosition.x)}, {F(spawnPosition.y)})");
        code.AppendLine("        );");

        code.AppendLine("    }");
        code.AppendLine("}");

        return code.ToString();
    }

    private static string F(float value)
    {
        return value.ToString("G", CultureInfo.InvariantCulture) + "f";
    }

    private struct Edge2D
    {
        public Vector2 Start;
        public Vector2 End;

        public Edge2D(Vector2 start, Vector2 end)
        {
            Start = start;
            End = end;
        }
    }
}
