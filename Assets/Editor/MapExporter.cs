using UnityEngine;
using UnityEditor;
using UnityEditor.SceneManagement;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;

public static class MapExporter
{
    private const float EdgeEpsilon = 0.01f;
    private static readonly string OutputDir = Path.Combine(Application.dataPath, "Scripts", "SharedPhysics");

    [MenuItem("Tools/Export Map Data")]
    public static void ExportMapData()
    {
        var terrainMeshes = Object.FindObjectsByType<TerrainMesh>(FindObjectsSortMode.None);
        if (terrainMeshes.Length == 0)
        {
            EditorUtility.DisplayDialog("Export Failed", "No TerrainMesh components found in the scene.", "OK");
            return;
        }

        var spawnPoints = Object.FindObjectsByType<SpawnPoint>(FindObjectsSortMode.None);
        if (spawnPoints.Length == 0)
        {
            EditorUtility.DisplayDialog("Export Failed", "No SpawnPoint components found in the scene.", "OK");
            return;
        }

        var allEdges = new List<Edge2D>();
        var allTriangles = new List<Triangle3D>();
        HeightmapExportData? heightmapData = null;

        foreach (var terrainMesh in terrainMeshes)
        {
            var meshFilter = terrainMesh.GetComponent<MeshFilter>();
            var unityTerrain = terrainMesh.GetComponent<Terrain>();

            if (meshFilter != null && meshFilter.sharedMesh != null)
            {
                // MeshFilter path: extract triangles and boundary edges from mesh
                var mesh = meshFilter.sharedMesh;
                var boundaryEdges = ExtractBoundaryEdges(mesh, terrainMesh.transform);
                allEdges.AddRange(boundaryEdges);

                var triangles = ExtractTriangles(mesh, terrainMesh.transform);
                allTriangles.AddRange(triangles);
            }
            else if (unityTerrain != null && unityTerrain.terrainData != null)
            {
                // Terrain path: extract heightmap data and boundary edges
                heightmapData = ExtractHeightmap(unityTerrain, terrainMesh.resolution);
                var boundaryEdges = ExtractHeightmapBoundaryEdges(heightmapData.Value);
                allEdges.AddRange(boundaryEdges);
            }
            else
            {
                Debug.LogWarning($"TerrainMesh on '{terrainMesh.name}' has no MeshFilter or Terrain component. Skipping.");
            }
        }

        var deduplicatedEdges = DeduplicateSharedEdges(allEdges);
        var deduplicatedTriangles = DeduplicateSharedTriangles(allTriangles);
        Debug.Log($"Extracted {allEdges.Count} boundary edges, {deduplicatedEdges.Count} after deduplication.");

        var spawnPos = spawnPoints[0].transform.position;
        var mapName = EditorSceneManager.GetActiveScene().name;

        // Write per-map file
        var mapFilePath = Path.Combine(OutputDir, $"MapData.{mapName}.cs");
        var mapCode = GenerateMapFile(mapName, deduplicatedEdges, deduplicatedTriangles, spawnPos, heightmapData);
        File.WriteAllText(mapFilePath, mapCode);

        // Regenerate index from all existing per-map files
        var allMapNames = DiscoverMapNames();
        var indexCode = GenerateIndexFile(allMapNames);
        var indexFilePath = Path.Combine(OutputDir, "MapData.cs");
        File.WriteAllText(indexFilePath, indexCode);

        AssetDatabase.Refresh();

        var statsMessage = heightmapData.HasValue
            ? $"Exported map '{mapName}' ({deduplicatedEdges.Count} collision lines, heightmap {heightmapData.Value.Resolution}x{heightmapData.Value.Resolution})."
            : $"Exported map '{mapName}' ({deduplicatedEdges.Count} collision lines, {deduplicatedTriangles.Count} triangles).";
        EditorUtility.DisplayDialog("Export Complete", $"{statsMessage}\n{allMapNames.Count} total map(s) registered.", "OK");
    }

    private static List<string> DiscoverMapNames()
    {
        var mapNames = new List<string>();
        foreach (var file in Directory.GetFiles(OutputDir, "MapData.*.cs"))
        {
            var fileName = Path.GetFileNameWithoutExtension(file);
            // fileName is "MapData.{MapName}", extract the map name
            var mapName = fileName.Substring("MapData.".Length);
            mapNames.Add(mapName);
        }
        mapNames.Sort();
        return mapNames;
    }

    private static string GenerateIndexFile(List<string> mapNames)
    {
        var code = new StringBuilder();
        code.AppendLine("// Auto-generated by MapExporter. Do not edit.");
        code.AppendLine("namespace SharedPhysics");
        code.AppendLine("{");
        code.AppendLine("    public static partial class MapData");
        code.AppendLine("    {");

        code.AppendLine("        public static MapDefinition GetMap(string name) => name switch");
        code.AppendLine("        {");
        foreach (var name in mapNames)
        {
            code.AppendLine($"            \"{name}\" => {name},");
        }
        code.AppendLine("            _ => throw new System.ArgumentException($\"Unknown map: {name}\")");
        code.AppendLine("        };");
        code.AppendLine();

        // Helper methods for converting flat float arrays to Line[]/Triangle[]
        code.AppendLine("        private static Line[] BuildLines(float[] data)");
        code.AppendLine("        {");
        code.AppendLine("            var result = new Line[data.Length / 4];");
        code.AppendLine("            for (int i = 0; i < result.Length; i++)");
        code.AppendLine("            {");
        code.AppendLine("                int j = i * 4;");
        code.AppendLine("                result[i] = new Line(new Vector2(data[j], data[j + 1]), new Vector2(data[j + 2], data[j + 3]));");
        code.AppendLine("            }");
        code.AppendLine("            return result;");
        code.AppendLine("        }");
        code.AppendLine();
        code.AppendLine("        private static Triangle[] BuildTriangles(float[] data)");
        code.AppendLine("        {");
        code.AppendLine("            var result = new Triangle[data.Length / 9];");
        code.AppendLine("            for (int i = 0; i < result.Length; i++)");
        code.AppendLine("            {");
        code.AppendLine("                int j = i * 9;");
        code.AppendLine("                result[i] = new Triangle(");
        code.AppendLine("                    new Vector3(data[j], data[j + 1], data[j + 2]),");
        code.AppendLine("                    new Vector3(data[j + 3], data[j + 4], data[j + 5]),");
        code.AppendLine("                    new Vector3(data[j + 6], data[j + 7], data[j + 8]));");
        code.AppendLine("            }");
        code.AppendLine("            return result;");
        code.AppendLine("        }");

        code.AppendLine("    }");
        code.AppendLine("}");

        return code.ToString();
    }

    private static string GenerateMapFile(string mapName, List<Edge2D> lines, List<Triangle3D> triangles,
        Vector3 spawnPosition, HeightmapExportData? heightmap)
    {
        var code = new StringBuilder();
        code.AppendLine("// Auto-generated by MapExporter. Do not edit.");
        code.AppendLine("namespace SharedPhysics");
        code.AppendLine("{");
        code.AppendLine("    public static partial class MapData");
        code.AppendLine("    {");

        // Line data as flat float array (4 floats per line: startX, startY, endX, endY)
        // Float arrays use RuntimeHelpers.InitializeArray (binary blob copy), avoiding large IL methods.
        code.AppendLine($"        private static readonly float[] _{mapName}LineData = new float[]");
        code.AppendLine("        {");
        for (int i = 0; i < lines.Count; i++)
        {
            var line = lines[i];
            code.AppendLine($"            {F(line.Start.x)},{F(line.Start.y)},{F(line.End.x)},{F(line.End.y)},");
        }
        code.AppendLine("        };");
        code.AppendLine();

        if (heightmap.HasValue)
        {
            var hm = heightmap.Value;

            // Heightmap data as flat float array (row-major: heights[z * resolution + x])
            code.AppendLine($"        private static readonly float[] _{mapName}HeightmapData = new float[]");
            code.AppendLine("        {");
            for (int z = 0; z < hm.Resolution; z++)
            {
                var sb = new StringBuilder("            ");
                for (int x = 0; x < hm.Resolution; x++)
                {
                    sb.Append(F(hm.Heights[z * hm.Resolution + x]));
                    sb.Append(',');
                }
                code.AppendLine(sb.ToString());
            }
            code.AppendLine("        };");
            code.AppendLine();

            // Lazy map definition using heightmap constructor
            code.AppendLine($"        private static readonly System.Lazy<MapDefinition> _{mapName}Lazy = new System.Lazy<MapDefinition>(() => new MapDefinition(");
            code.AppendLine($"            \"{mapName}\",");
            code.AppendLine($"            BuildLines(_{mapName}LineData),");
            code.AppendLine($"            new Vector3({F(spawnPosition.x)}, {F(spawnPosition.y)}, {F(spawnPosition.z)}),");
            code.AppendLine($"            _{mapName}HeightmapData,");
            code.AppendLine($"            {hm.Resolution},");
            code.AppendLine($"            {F(hm.OriginX)},");
            code.AppendLine($"            {F(hm.OriginZ)},");
            code.AppendLine($"            {F(hm.SizeX)},");
            code.AppendLine($"            {F(hm.SizeZ)}");
            code.AppendLine("        ));");
        }
        else
        {
            // Triangle data as flat float array (9 floats per tri: v0x,v0y,v0z, v1x,v1y,v1z, v2x,v2y,v2z)
            code.AppendLine($"        private static readonly float[] _{mapName}TriangleData = new float[]");
            code.AppendLine("        {");
            for (int i = 0; i < triangles.Count; i++)
            {
                var tri = triangles[i];
                code.AppendLine($"            {F(tri.V0.x)},{F(tri.V0.y)},{F(tri.V0.z)},{F(tri.V1.x)},{F(tri.V1.y)},{F(tri.V1.z)},{F(tri.V2.x)},{F(tri.V2.y)},{F(tri.V2.z)},");
            }
            code.AppendLine("        };");
            code.AppendLine();

            // Lazy map definition using triangle constructor
            code.AppendLine($"        private static readonly System.Lazy<MapDefinition> _{mapName}Lazy = new System.Lazy<MapDefinition>(() => new MapDefinition(");
            code.AppendLine($"            \"{mapName}\",");
            code.AppendLine($"            BuildLines(_{mapName}LineData),");
            code.AppendLine($"            BuildTriangles(_{mapName}TriangleData),");
            code.AppendLine($"            new Vector3({F(spawnPosition.x)}, {F(spawnPosition.y)}, {F(spawnPosition.z)})");
            code.AppendLine("        ));");
        }

        code.AppendLine($"        public static MapDefinition {mapName} => _{mapName}Lazy.Value;");

        code.AppendLine("    }");
        code.AppendLine("}");

        return code.ToString();
    }

    private struct HeightmapExportData
    {
        public float[] Heights;
        public int Resolution;
        public float OriginX, OriginZ;
        public float SizeX, SizeZ;
    }

    private static HeightmapExportData ExtractHeightmap(Terrain terrain, int resolution)
    {
        var data = terrain.terrainData;
        var hmRes = data.heightmapResolution;
        var size = data.size;
        var pos = terrain.transform.position;

        resolution = Mathf.Clamp(resolution, 2, hmRes);
        int step = Mathf.Max(1, (hmRes - 1) / (resolution - 1));
        int actualRes = (hmRes - 1) / step + 1;

        var unityHeights = data.GetHeights(0, 0, hmRes, hmRes);
        var heights = new float[actualRes * actualRes];

        for (int z = 0; z < actualRes; z++)
        {
            for (int x = 0; x < actualRes; x++)
            {
                int hmX = Mathf.Min(x * step, hmRes - 1);
                int hmZ = Mathf.Min(z * step, hmRes - 1);
                heights[z * actualRes + x] = unityHeights[hmZ, hmX] * size.y + pos.y;
            }
        }

        Debug.Log($"Extracted heightmap from Terrain '{terrain.name}': {actualRes}x{actualRes} grid, {heights.Length} heights");

        return new HeightmapExportData
        {
            Heights = heights,
            Resolution = actualRes,
            OriginX = pos.x,
            OriginZ = pos.z,
            SizeX = size.x,
            SizeZ = size.z
        };
    }

    private static List<Edge2D> ExtractHeightmapBoundaryEdges(HeightmapExportData hm)
    {
        var edges = new List<Edge2D>();
        float cellX = hm.SizeX / (hm.Resolution - 1);
        float cellZ = hm.SizeZ / (hm.Resolution - 1);

        for (int i = 0; i < hm.Resolution - 1; i++)
        {
            float x0 = hm.OriginX + i * cellX;
            float x1 = hm.OriginX + (i + 1) * cellX;

            // Top edge (z = originZ)
            edges.Add(new Edge2D(new Vector2(x0, hm.OriginZ), new Vector2(x1, hm.OriginZ)));
            // Bottom edge (z = originZ + sizeZ)
            edges.Add(new Edge2D(
                new Vector2(x0, hm.OriginZ + hm.SizeZ),
                new Vector2(x1, hm.OriginZ + hm.SizeZ)));
        }

        for (int i = 0; i < hm.Resolution - 1; i++)
        {
            float z0 = hm.OriginZ + i * cellZ;
            float z1 = hm.OriginZ + (i + 1) * cellZ;

            // Left edge (x = originX)
            edges.Add(new Edge2D(new Vector2(hm.OriginX, z0), new Vector2(hm.OriginX, z1)));
            // Right edge (x = originX + sizeX)
            edges.Add(new Edge2D(
                new Vector2(hm.OriginX + hm.SizeX, z0),
                new Vector2(hm.OriginX + hm.SizeX, z1)));
        }

        return edges;
    }

    private static List<Triangle3D> ExtractTriangles(Mesh mesh, Transform transform)
    {
        var triangles = mesh.triangles;
        var vertices = mesh.vertices;
        var result = new List<Triangle3D>();

        for (int i = 0; i < triangles.Length; i += 3)
        {
            var worldV0 = transform.TransformPoint(vertices[triangles[i]]);
            var worldV1 = transform.TransformPoint(vertices[triangles[i + 1]]);
            var worldV2 = transform.TransformPoint(vertices[triangles[i + 2]]);

            result.Add(new Triangle3D(worldV0, worldV1, worldV2));
        }

        return result;
    }

    private static List<Edge2D> ExtractBoundaryEdges(Mesh mesh, Transform transform)
    {
        var triangles = mesh.triangles;
        var vertices = mesh.vertices;
        var edgeCounts = new Dictionary<(int, int), int>();

        for (int i = 0; i < triangles.Length; i += 3)
        {
            var v0 = triangles[i];
            var v1 = triangles[i + 1];
            var v2 = triangles[i + 2];

            CountEdge(edgeCounts, v0, v1);
            CountEdge(edgeCounts, v1, v2);
            CountEdge(edgeCounts, v2, v0);
        }

        var boundaryEdges = new List<Edge2D>();
        foreach (var kvp in edgeCounts)
        {
            if (kvp.Value != 1) continue;

            var worldA = transform.TransformPoint(vertices[kvp.Key.Item1]);
            var worldB = transform.TransformPoint(vertices[kvp.Key.Item2]);

            boundaryEdges.Add(new Edge2D(
                new Vector2(worldA.x, worldA.z),
                new Vector2(worldB.x, worldB.z)
            ));
        }

        return boundaryEdges;
    }

    private static void CountEdge(Dictionary<(int, int), int> edgeCounts, int a, int b)
    {
        var key = a < b ? (a, b) : (b, a);
        edgeCounts.TryGetValue(key, out var count);
        edgeCounts[key] = count + 1;
    }

    private static List<Edge2D> DeduplicateSharedEdges(List<Edge2D> edges)
    {
        var result = new List<Edge2D>();
        var removed = new bool[edges.Count];

        for (int i = 0; i < edges.Count; i++)
        {
            if (removed[i]) continue;

            bool isDuplicate = false;
            for (int j = i + 1; j < edges.Count; j++)
            {
                if (removed[j]) continue;
                if (!EdgesMatch(edges[i], edges[j])) continue;

                removed[i] = true;
                removed[j] = true;
                isDuplicate = true;
                break;
            }

            if (!isDuplicate)
            {
                result.Add(edges[i]);
            }
        }

        return result;
    }

    private static List<Triangle3D> DeduplicateSharedTriangles(List<Triangle3D> triangles)
    {
        var result = new List<Triangle3D>();
        var removed = new bool[triangles.Count];

        for (int i = 0; i < triangles.Count; i++)
        {
            if (removed[i]) continue;

            bool isDuplicate = false;
            for (int j = i + 1; j < triangles.Count; j++)
            {
                if (removed[j]) continue;
                if (!TrianglesMatch(triangles[i], triangles[j])) continue;

                removed[i] = true;
                removed[j] = true;
                isDuplicate = true;
                break;
            }

            if (!isDuplicate)
            {
                result.Add(triangles[i]);
            }
        }

        return result;
    }

    private static bool TrianglesMatch(Triangle3D a, Triangle3D b)
    {
        var aVerts = new[] { a.V0, a.V1, a.V2 };
        var bVerts = new[] { b.V0, b.V1, b.V2 };

        // Check if all vertices of a match some vertex in b
        foreach (var av in aVerts)
        {
            bool found = false;
            foreach (var bv in bVerts)
            {
                if (ApproxEqual3D(av, bv))
                {
                    found = true;
                    break;
                }
            }
            if (!found) return false;
        }
        return true;
    }

    private static bool EdgesMatch(Edge2D a, Edge2D b)
    {
        return (ApproxEqual(a.Start, b.Start) && ApproxEqual(a.End, b.End)) ||
               (ApproxEqual(a.Start, b.End) && ApproxEqual(a.End, b.Start));
    }

    private static bool ApproxEqual(Vector2 a, Vector2 b)
    {
        return Mathf.Abs(a.x - b.x) < EdgeEpsilon && Mathf.Abs(a.y - b.y) < EdgeEpsilon;
    }

    private static bool ApproxEqual3D(Vector3 a, Vector3 b)
    {
        return Mathf.Abs(a.x - b.x) < EdgeEpsilon &&
               Mathf.Abs(a.y - b.y) < EdgeEpsilon &&
               Mathf.Abs(a.z - b.z) < EdgeEpsilon;
    }

    private static string F(float value)
    {
        return value.ToString("G", CultureInfo.InvariantCulture) + "f";
    }

    private struct Edge2D
    {
        public Vector2 Start;
        public Vector2 End;

        public Edge2D(Vector2 start, Vector2 end)
        {
            Start = start;
            End = end;
        }
    }

    private struct Triangle3D
    {
        public Vector3 V0;
        public Vector3 V1;
        public Vector3 V2;

        public Triangle3D(Vector3 v0, Vector3 v1, Vector3 v2)
        {
            V0 = v0;
            V1 = v1;
            V2 = v2;
        }
    }
}
